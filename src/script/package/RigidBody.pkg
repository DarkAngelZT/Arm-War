class RigidBody
{
public:
	//general interface
	void applyGravity();

	void setGravity(irr::core::vector3d<float>& acceleration);

	irr::core::vector3d<float> getGravity() const;

	void setDamping(float lin_damping, float ang_damping);

	float getLinearDamping() const;

	float getAngularDamping() const;

	float getLinearSleepingThreshold() const;

	float getAngularSleepingThreshold() const;

	void applyDamping(float timeStep);

	void setMassProps(float mass, irr::core::vector3d<float>& inertia);

	const irr::core::vector3d<float> getLinearFactor() const;
	void setLinearFactor(irr::core::vector3d<float>& linearFactor);
	float getInvMass() const;

	void integrateVelocities(float step);

	void setCenterOfMassTransform(irr::core::matrix4& xform);

	void applyCentralForce(irr::core::vector3d<float>& force);

	const irr::core::vector3d<float> getTotalForce() const;

	const irr::core::vector3d<float> getTotalTorque() const;

	const irr::core::vector3d<float> getInvInertiaDiagLocal() const;

	void setInvInertiaDiagLocal(irr::core::vector3d<float>& diagInvInertia);

	void setSleepingThresholds(float linear, float angular);

	void applyTorque(irr::core::vector3d<float>& torque);

	void applyForce(irr::core::vector3d<float>& force, irr::core::vector3d<float>& rel_pos);

	void applyCentralImpulse(irr::core::vector3d<float>& impulse);

	void applyTorqueImpulse(irr::core::vector3d<float>& torque);

	void applyImpulse(irr::core::vector3d<float>& impulse,
			irr::core::vector3d<float>& rel_pos);

	void clearForces();

	void updateInertiaTensor();

	const irr::core::vector3d<float> getCenterOfMassPosition() const;
	irr::core::quaternion getOrientation() const;

	irr::core::matrix4 getCenterOfMassTransform() const;
	irr::core::vector3d<float> getLinearVelocity() const;
	irr::core::vector3d<float> getAngularVelocity() const;

	void setLinearVelocity(irr::core::vector3d<float>& lin_vel);

	void setAngularVelocity(irr::core::vector3d<float>& ang_vel);

	irr::core::vector3d<float> getVelocityInLocalPoint(
			irr::core::vector3d<float>& rel_pos) const;

	void translate(irr::core::vector3d<float>& v);

	void getAabb(irr::core::vector3d<float>& aabbMin,
			irr::core::vector3d<float>& aabbMax) const;

	float computeImpulseDenominator(irr::core::vector3d<float>& pos,
			irr::core::vector3d<float>& normal) const;

	float computeAngularImpulseDenominator(irr::core::vector3d<float>& axis) const;

	void updateDeactivation(float timeStep);

	void setAngularFactor(irr::core::vector3d<float>& angFac);

	void setAngularFactor(float angFac);

	irr::core::vector3d<float> getAngularFactor() const;
	void setPosition(irr::core::vector3d<float> position);
	void setRotation(irr::core::vector3d<float> rotation);
};
