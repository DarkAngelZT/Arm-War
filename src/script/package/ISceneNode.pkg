// Author: Neo @ 2016

namespace irr
{
namespace scene
{

	class ISceneNode
	{
	public:

		//! Renders the node.
		virtual void render();


		//! Returns the name of the node.
		/** \return Name as character string. */
		virtual const char* getName() const;


		//! Sets the name of the node.
		/** \param name New name of the scene node. */
		virtual void setName(const char* name);


		//! Get the axis aligned, not transformed bounding box of this node.
		/** This means that if this node is an animated 3d character,
		moving in a room, the bounding box will always be around the
		origin. To get the box in real world coordinates, just
		transform it with the matrix you receive with
		getAbsoluteTransformation() or simply use
		getTransformedBoundingBox(), which does the same.
		\return The non-transformed bounding box. */
		virtual const irr::core::aabbox3df& getBoundingBox() const;


		//! Get the axis aligned, transformed and animated absolute bounding box of this node.
		/** \return The transformed bounding box. */
		virtual const irr::core::aabbox3df getTransformedBoundingBox() const;


		//! Get the absolute transformation of the node. Is recalculated every OnAnimate()-call.
		/** NOTE: For speed reasons the absolute transformation is not 
		automatically recalculated on each change of the relative 
		transformation or by a transformation change of an parent. Instead the
		update usually happens once per frame in OnAnimate. You can enforce 
		an update with updateAbsolutePosition().
		\return The absolute transformation matrix. */
		virtual const irr::core::CMatrix4<float>& getAbsoluteTransformation() const;


		//! Returns the relative transformation of the scene node.
		/** The relative transformation is stored internally as 3
		vectors: translation, rotation and scale. To get the relative
		transformation matrix, it is calculated from these values.
		\return The relative transformation matrix. */
		virtual irr::core::CMatrix4<float> getRelativeTransformation() const;


		//! Returns whether the node should be visible (if all of its parents are visible).
		/** This is only an option set by the user, but has nothing to
		do with geometry culling
		\return The requested visibility of the node, true means
		visible (if all parents are also visible). */
		virtual bool isVisible() const;

		//! Check whether the node is truly visible, taking into accounts its parents' visibility
		/** \return true if the node and all its parents are visible,
		false if this or any parent node is invisible. */
		virtual bool isTrulyVisible() const;

		//! Sets if the node should be visible or not.
		/** All children of this node won't be visible either, when set
		to false. Invisible nodes are not valid candidates for selection by
		collision manager bounding box methods.
		\param isVisible If the node shall be visible. */
		virtual void setVisible(bool isVisible);


		//! Get the id of the scene node.
		/** This id can be used to identify the node.
		\return The id. */
		virtual int getID() const;


		//! Sets the id of the scene node.
		/** This id can be used to identify the node.
		\param id The new id. */
		virtual void setID(int id);

		//! Adds a child to this scene node.
		/** If the scene node already has a parent it is first removed
		from the other parent.
		\param child A pointer to the new child. */
		virtual void addChild(ISceneNode* child);


		//! Removes a child from this scene node.
		/** If found in the children list, the child pointer is also
		dropped and might be deleted if no other grab exists.
		\param child A pointer to the child which shall be removed.
		\return True if the child was removed, and false if not,
		e.g. because it couldn't be found in the children list. */
		virtual bool removeChild(ISceneNode* child);

		//! Removes all children of this scene node
		/** The scene nodes found in the children list are also dropped
		and might be deleted if no other grab exists on them.
		*/
		virtual void removeAll();


		//! Removes this scene node from the scene
		/** If no other grab exists for this node, it will be deleted.
		*/
		virtual void remove();


		//! Adds an animator which should animate this node.
		/** \param animator A pointer to the new animator. */
		virtual void addAnimator(ISceneNodeAnimator* animator);


		//! Get a list of all scene node animators.
		/** \return The list of animators attached to this node. */
		//const core::list<ISceneNodeAnimator*>& getAnimators() const;


		//! Removes an animator from this scene node.
		/** If the animator is found, it is also dropped and might be
		deleted if not other grab exists for it.
		\param animator A pointer to the animator to be deleted. */
		virtual void removeAnimator(ISceneNodeAnimator* animator);

		//! Removes all animators from this scene node.
		/** The animators might also be deleted if no other grab exists
		for them. */
		virtual void removeAnimators();


		//! Returns the material based on the zero based index i.
		/** To get the amount of materials used by this scene node, use
		getMaterialCount(). This function is needed for inserting the
		node into the scene hierarchy at an optimal position for
		minimizing renderstate changes, but can also be used to
		directly modify the material of a scene node.
		\param num Zero based index. The maximal value is getMaterialCount() - 1.
		\return The material at that index. */
		//virtual video::SMaterial& getMaterial(unsigned int num);


		//! Get amount of materials used by this scene node.
		/** \return Current amount of materials of this scene node. */
		virtual unsigned int getMaterialCount() const;


		//! Sets all material flags at once to a new value.
		/** Useful, for example, if you want the whole mesh to be
		affected by light.
		\param flag Which flag of all materials to be set.
		\param newvalue New value of that flag. */
		void setMaterialFlag(video::E_MATERIAL_FLAG flag, bool newvalue);


		//! Sets the texture of the specified layer in all materials of this scene node to the new texture.
		/** \param textureLayer Layer of texture to be set. Must be a
		value smaller than MATERIAL_MAX_TEXTURES.
		\param texture New texture to be used. */
		void setMaterialTexture(unsigned int textureLayer, video::ITexture* texture);


		//! Sets the material type of all materials in this scene node to a new material type.
		/** \param newType New type of material to be set. */
		void setMaterialType(video::E_MATERIAL_TYPE newType);


		//! Gets the scale of the scene node relative to its parent.
		/** This is the scale of this node relative to its parent.
		If you want the absolute scale, use
		getAbsoluteTransformation().getScale()
		\return The scale of the scene node. */
		virtual const irr::core::vector3d<float>& getScale() const;


		//! Sets the relative scale of the scene node.
		/** \param scale New scale of the node, relative to its parent. */
		virtual void setScale(const irr::core::vector3d<float>& scale);


		//! Gets the rotation of the node relative to its parent.
		/** Note that this is the relative rotation of the node.
		If you want the absolute rotation, use
		getAbsoluteTransformation().getRotation()
		\return Current relative rotation of the scene node. */
		virtual const irr::core::vector3d<float>& getRotation() const;


		//! Sets the rotation of the node relative to its parent.
		/** This only modifies the relative rotation of the node.
		\param rotation New rotation of the node in degrees. */
		virtual void setRotation(const irr::core::vector3d<float>& rotation);


		//! Gets the position of the node relative to its parent.
		/** Note that the position is relative to the parent. If you want
		the position in world coordinates, use getAbsolutePosition() instead.
		\return The current position of the node relative to the parent. */
		virtual const irr::core::vector3d<float>& getPosition() const;


		//! Sets the position of the node relative to its parent.
		/** Note that the position is relative to the parent.
		\param newpos New relative position of the scene node. */
		virtual void setPosition(const irr::core::vector3d<float>& newpos);


		//! Gets the absolute position of the node in world coordinates.
		/** If you want the position of the node relative to its parent,
		use getPosition() instead.
		NOTE: For speed reasons the absolute position is not 
		automatically recalculated on each change of the relative 
		position or by a position change of an parent. Instead the 
		update usually happens once per frame in OnAnimate. You can enforce 
		an update with updateAbsolutePosition().
		\return The current absolute position of the scene node (updated on last call of updateAbsolutePosition). */
		virtual irr::core::vector3d<float> getAbsolutePosition() const;


		//! Enables or disables automatic culling based on the bounding box.
		/** Automatic culling is enabled by default. Note that not
		all SceneNodes support culling and that some nodes always cull
		their geometry because it is their only reason for existence,
		for example the OctreeSceneNode.
		\param state The culling state to be used. */
		void setAutomaticCulling( unsigned int state);


		//! Gets the automatic culling state.
		/** \return The automatic culling state. */
		unsigned int getAutomaticCulling() const;


		//! Sets if debug data like bounding boxes should be drawn.
		/** A bitwise OR of the types from @ref irr::scene::E_DEBUG_SCENE_TYPE.
		Please note that not all scene nodes support all debug data types.
		\param state The debug data visibility state to be used. */
		virtual void setDebugDataVisible(unsigned int state);

		//! Returns if debug data like bounding boxes are drawn.
		/** \return A bitwise OR of the debug data values from
		@ref irr::scene::E_DEBUG_SCENE_TYPE that are currently visible. */
		unsigned int isDebugDataVisible() const;


		//! Sets if this scene node is a debug object.
		/** Debug objects have some special properties, for example they can be easily
		excluded from collision detection or from serialization, etc. */
		void setIsDebugObject(bool debugObject);


		//! Returns if this scene node is a debug object.
		/** Debug objects have some special properties, for example they can be easily
		excluded from collision detection or from serialization, etc.
		\return If this node is a debug object, true is returned. */
		bool isDebugObject() const;


		//! Returns a const reference to the list of all children.
		/** \return The list of all children of this node. */
		//const core::list<ISceneNode*>& getChildren() const;


		//! Changes the parent of the scene node.
		/** \param newParent The new parent to be used. */
		virtual void setParent(ISceneNode* newParent);


		//! Returns the triangle selector attached to this scene node.
		/** The Selector can be used by the engine for doing collision
		detection. You can create a TriangleSelector with
		ISceneManager::createTriangleSelector() or
		ISceneManager::createOctreeTriangleSelector and set it with
		ISceneNode::setTriangleSelector(). If a scene node got no triangle
		selector, but collision tests should be done with it, a triangle
		selector is created using the bounding box of the scene node.
		\return A pointer to the TriangleSelector or 0, if there
		is none. */
		//virtual ITriangleSelector* getTriangleSelector() const;


		//! Sets the triangle selector of the scene node.
		/** The Selector can be used by the engine for doing collision
		detection. You can create a TriangleSelector with
		ISceneManager::createTriangleSelector() or
		ISceneManager::createOctreeTriangleSelector(). Some nodes may
		create their own selector by default, so it would be good to
		check if there is already a selector in this node by calling
		ISceneNode::getTriangleSelector().
		\param selector New triangle selector for this scene node. */
		//virtual void setTriangleSelector(ITriangleSelector* selector);


		//! Updates the absolute position based on the relative and the parents position
		/** Note: This does not recursively update the parents absolute positions, so if you have a deeper
			hierarchy you might want to update the parents first.*/
		virtual void updateAbsolutePosition();


		//! Returns the parent of this scene node
		/** \return A pointer to the parent. */
		scene::ISceneNode* getParent() const;


		//! Returns type of the scene node
		/** \return The type of this node. */
		virtual ESCENE_NODE_TYPE getType() const;

		//! Creates a clone of this scene node and its children.
		/** \param newParent An optional new parent.
		\param newManager An optional new scene manager.
		\return The newly created clone of this node. */
		virtual ISceneNode* clone(ISceneNode* newParent=0);//, ISceneManager* newManager=0);

	};


} // end namespace scene
} // end namespace irr


