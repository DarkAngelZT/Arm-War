namespace irr
{
namespace scene
{
	//! Scene Node which is a (controlable) camera.
	/** The whole scene will be rendered from the cameras point of view.
	Because the ICameraScenNode is a SceneNode, it can be attached to any
	other scene node, and will follow its parents movement, rotation and so
	on.
	*/
	class ICameraSceneNode : public ISceneNode
	{
	public:
		//! Sets the projection matrix of the camera.
		/** The core::CMatrix4<float> class has some methods to build a
		projection matrix. e.g:
		core::CMatrix4<float>::buildProjectionMatrixPerspectiveFovLH.
		Note that the matrix will only stay as set by this method until
		one of the following Methods are called: setNearValue,
		setFarValue, setAspectRatio, setFOV.
		\param projection The new projection matrix of the camera.
		\param isOrthogonal Set this to true if the matrix is an
		orthogonal one (e.g. from CMatrix4<float>::buildProjectionMatrixOrtho).
		*/
		virtual void setProjectionMatrix(const irr::core::CMatrix4<float>& projection, bool isOrthogonal=false);

		//! Gets the current projection matrix of the camera.
		/** \return The current projection matrix of the camera. */
		virtual const irr::core::CMatrix4<float>& getProjectionMatrix() const ;

		//! Gets the current view matrix of the camera.
		/** \return The current view matrix of the camera. */
		virtual const irr::core::CMatrix4<float>& getViewMatrix() const ;

		//! Sets a custom view matrix affector.
		/** The matrix passed here, will be multiplied with the view
		matrix when it gets updated. This allows for custom camera
		setups like, for example, a reflection camera.
		\param affector The affector matrix. */
		virtual void setViewMatrixAffector(const irr::core::CMatrix4<float>& affector) ;

		//! Get the custom view matrix affector.
		/** \return The affector matrix. */
		virtual const irr::core::CMatrix4<float>& getViewMatrixAffector() const ;

		//! Sets the look at target of the camera
		/** If the camera's target and rotation are bound ( @see
		bindTargetAndRotation() ) then calling this will also change
		the camera's scene node rotation to match the target.
		Note that setTarget uses the current absolute position 
		internally, so if you changed setPosition since last rendering you must
		call updateAbsolutePosition before using this function.
		\param pos Look at target of the camera, in world co-ordinates. */
		virtual void setTarget(const irr::core::vector3d<float>& pos) ;

		//! Sets the rotation of the node.
		/** This only modifies the relative rotation of the node.
		If the camera's target and rotation are bound ( @see
		bindTargetAndRotation() ) then calling this will also change
		the camera's target to match the rotation.
		\param rotation New rotation of the node in degrees. */
		virtual void setRotation(const irr::core::vector3d<float>& rotation) ;

		//! Gets the current look at target of the camera
		/** \return The current look at target of the camera, in world co-ordinates */
		virtual const irr::core::vector3d<float>& getTarget() const ;

		//! Sets the up vector of the camera.
		/** \param pos: New upvector of the camera. */
		virtual void setUpVector(const irr::core::vector3d<float>& pos) ;

		//! Gets the up vector of the camera.
		/** \return The up vector of the camera, in world space. */
		virtual const irr::core::vector3d<float>& getUpVector() const ;

		//! Gets the value of the near plane of the camera.
		/** \return The value of the near plane of the camera. */
		virtual float getNearValue() const ;

		//! Gets the value of the far plane of the camera.
		/** \return The value of the far plane of the camera. */
		virtual float getFarValue() const ;

		//! Gets the aspect ratio of the camera.
		/** \return The aspect ratio of the camera. */
		virtual float getAspectRatio() const ;

		//! Gets the field of view of the camera.
		/** \return The field of view of the camera in radians. */
		virtual float getFOV() const ;

		//! Sets the value of the near clipping plane. (default: 1.0f)
		/** \param zn: New z near value. */
		virtual void setNearValue(float zn) ;

		//! Sets the value of the far clipping plane (default: 2000.0f)
		/** \param zf: New z far value. */
		virtual void setFarValue(float zf) ;

		//! Sets the aspect ratio (default: 4.0f / 3.0f)
		/** \param aspect: New aspect ratio. */
		virtual void setAspectRatio(float aspect) ;

		//! Sets the field of view (Default: PI / 2.5f)
		/** \param fovy: New field of view in radians. */
		virtual void setFOV(float fovy) ;

		//! Disables or enables the camera to get key or mouse inputs.
		/** If this is set to true, the camera will respond to key
		inputs otherwise not. */
		virtual void setInputReceiverEnabled(bool enabled) ;

		//! Checks if the input receiver of the camera is currently enabled.
		virtual bool isInputReceiverEnabled() const ;

		//! Checks if a camera is orthogonal.
		virtual bool isOrthogonal() const;

		//! Binds the camera scene node's rotation to its target position and vice vera, or unbinds them.
		/** When bound, calling setRotation() will update the camera's
		target position to be along its +Z axis, and likewise calling
		setTarget() will update its rotation so that its +Z axis will
		point at the target point. FPS camera use this binding by
		default; other cameras do not.
		\param bound True to bind the camera's scene node rotation
		and targetting, false to unbind them.
		@see getTargetAndRotationBinding() */
		virtual void bindTargetAndRotation(bool bound) ;

		//! Queries if the camera scene node's rotation and its target position are bound together.
		/** @see bindTargetAndRotation() */
		virtual bool getTargetAndRotationBinding(void) const ;

	};

} // end namespace scene
} // end namespace irr


